<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>投稿ガチャ</title>
  <style>
    :root{
      --overlap:14px;
      --sticker-space: clamp(120px, 22vw, 160px); /* 贴纸顶部预留空间 */
      --sticker-scale: 1.1;                       /* 贴纸整体放大 10% */
    }
    body{
      background:#000; color:#fff; font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Noto Sans JP",sans-serif;
      text-align:center; margin:0; padding:24px 12px;
    }
    /* 投稿卡片整体下移，给贴纸留空间 */
    .card{
      background:#111;
      margin: calc(16px + var(--sticker-space)) auto 24px;
      padding:16px; border-radius:12px; max-width:420px;
    }
    .card img{ max-width:100%; border-radius:8px; }
    button{
      background:#f2c94c; border:none; padding:10px 20px; border-radius:8px;
      font-size:16px; cursor:pointer; margin:8px;
    }
    #error{ color:#f88; margin-top:10px; }
    canvas#confetti{ position:fixed; inset:0; width:100%; height:100%; pointer-events:none; z-index:999; }

    /* ===== 贴纸：定位与动画 ===== */
    #sticker{
      position:absolute;
      left:50%;
      /* 初始就按 1.1 放大；所有动画里的 transform 都带上 scale，避免相互覆盖 */
      transform:translateX(-50%) scale(var(--sticker-scale));
      top:-30vh;
      width:clamp(90px,18vw,140px);
      z-index:10;
      pointer-events:none;
      opacity:0;
      will-change: transform, top, opacity;
    }
    /* 掉落 + 轻微回弹（一次性） */
    #sticker.drop{
      animation:
        stickerDrop 0.85s cubic-bezier(.22,.85,.34,1) forwards,
        stickerBounce 0.22s 0.85s ease-out forwards;
    }
    @keyframes stickerDrop{
      from{ top:-30vh; opacity:0; }
      to  { top: var(--sticker-end, 0px); opacity:1; }
    }
    @keyframes stickerBounce{
      0%   { transform:translateX(-50%) translateY(0)    scale(var(--sticker-scale)); }
      60%  { transform:translateX(-50%) translateY(-6px) scale(var(--sticker-scale)); }
      100% { transform:translateX(-50%) translateY(0)    scale(var(--sticker-scale)); }
    }
    /* 落定后的“上下浮动”（循环） */
    #sticker.float{
      animation: stickerFloat 2.8s ease-in-out infinite;
    }
    @keyframes stickerFloat{
      0%   { transform:translateX(-50%) translateY(0)    scale(var(--sticker-scale)); }
      50%  { transform:translateX(-50%) translateY(-6px) scale(var(--sticker-scale)); }
      100% { transform:translateX(-50%) translateY(0)    scale(var(--sticker-scale)); }
    }
  </style>
</head>
<body>

  <div class="card" id="result">読み込み中...</div>

  <button onclick="location.href='https://docs.google.com/forms/...yourFormURL...'">もう一度投稿する</button>

  <div id="error"></div>
  <canvas id="confetti"></canvas>

  <!-- 贴纸元素 -->
  <img id="sticker" alt="sticker"/>

  <script>
    const API_BASE = "https://script.google.com/macros/s/AKfycbzohTsM5dhSUFTMTgc2c8OEoOJsIHZpz00aSl1FIgF6rjsS_MRPr_uWP1o-nlNttA0IVw/exec";

    const urlParams = new URLSearchParams(window.location.search);
    const spot = (urlParams.get("spot") || "veg").toLowerCase();
    const sid  = urlParams.get("sid") || "";

    const STICKER_COUNT = 10;
    const VALID_SPOTS = ["veg","dairy","staple"];
    function randomStickerPath(spotName){
      const s = VALID_SPOTS.includes(spotName) ? spotName : "veg";
      const n = Math.floor(Math.random() * STICKER_COUNT) + 1;
      const two = n.toString().padStart(2,"0");
      return `./assets/stickers/${s}/sticker-${two}.png`;
    }

    /* 第一次彩纸：两侧喷（保持原样） */
    function fireConfetti() {
      const duration = 1500;
      const end = Date.now() + duration;
      (function frame() {
        confetti({ particleCount: 3, angle: 60,  spread: 55, origin: { x: 0 } });
        confetti({ particleCount: 3, angle: 120, spread: 55, origin: { x: 1 } });
        if (Date.now() < end) requestAnimationFrame(frame);
      })();
    }

    /* 第二次彩纸：从顶部飘落（尺寸/密度/颜色不变） */
    function fireConfettiTop() {
      const duration = 1200;
      const end = Date.now() + duration;
      (function frame() {
        confetti({
          particleCount: 3,
          spread: 55,
          origin: { x: Math.random(), y: 0 }
        });
        if (Date.now() < end) requestAnimationFrame(frame);
      })();
    }

    /* 贴纸：预加载 + 掉落到预定位置；在回弹动画结束时进入“浮动”，并触发二次彩纸 */
    function runStickerSequence() {
      const imgEl = document.getElementById("sticker");
      const path = randomStickerPath(spot);
      const pre = new Image();
      pre.onload = () => {
        imgEl.src = path;

        // 落点：距离顶部 60px（可调整） - 轻微重叠
        const endPx = 60 - parseInt(getComputedStyle(document.documentElement).getPropertyValue('--overlap'));
        imgEl.style.setProperty('--sticker-end', endPx + 'px');

        // 重置并播放“掉落+回弹”
        imgEl.classList.remove('drop','float');  // 确保可重复播放
        void imgEl.offsetWidth;                  // 触发重排
        imgEl.classList.add('drop');

        // 只在第二段动画 stickerBounce 结束后再进入“浮动”，避免中途状态导致消失
        const onEnd = (e) => {
          if (e.animationName === 'stickerBounce') {
            imgEl.classList.add('float'); // 开始持续上下浮动
            fireConfettiTop();            // 第二次彩纸
            imgEl.removeEventListener('animationend', onEnd);
          }
        };
        imgEl.addEventListener('animationend', onEnd);
      };
      pre.onerror = () => fireConfettiTop();
      pre.src = path;
    }

    async function getOne() {
      const result = document.getElementById("result");
      const error  = document.getElementById("error");
      result.textContent = "読み込み中...";
      error.textContent = "";

      try {
        const API = `${API_BASE}?spot=${encodeURIComponent(spot)}&mode=list`;
        const r = await fetch(API);
        const j = await r.json();

        if (j.status === 200 && Array.isArray(j.data)) {
          let list = j.data.filter(x => !sid || x.id !== sid);
          if (list.length === 0) list = j.data;
          const one = list[Math.floor(Math.random() * list.length)];
          result.innerHTML = `
            <p><img src="${one.img}" alt="post photo"></p>
            <p>${one.text ? one.text : "(no text)"}</p>
          `;
          fireConfetti();
          runStickerSequence();
        } else {
          error.textContent = "データ取得エラー: " + JSON.stringify(j);
        }
      } catch (err) {
        console.error(err);
        error.textContent = "ネットワークエラー: データを取得できません";
      }
    }

    getOne();
  </script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
</body>
</html>
